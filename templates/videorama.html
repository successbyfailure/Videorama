<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{ app_name }} · Biblioteca retro</title>
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA2NCA2NCcgZmlsbD0nbm9uZSc+CjxyZWN0IHdpZHRoPSc2NCcgaGVpZ2h0PSc2NCcgcng9JzE2JyBmaWxsPScjMGYxNzJhJy8+CjxjaXJjbGUgY3g9JzI2JyBjeT0nMzInIHI9JzE0JyBzdHJva2U9JyMyMmQzZWUnIHN0cm9rZS13aWR0aD0nNCcgZmlsbD0nbm9uZScvPgo8cGF0aCBkPSdNMzIgMjJsMTYgMTAtMTYgMTBWMjJ6JyBmaWxsPScjZjk3MzE2Jy8+Cjwvc3ZnPg=="
    />
    <style>
      :root {
        color-scheme: dark;
        font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #020617;
        color: #e2e8f0;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, #1e1b4b, #020617 60%);
        padding: clamp(1rem, 2vw, 2.5rem);
      }
      a {
        color: inherit;
      }
      .app-shell {
        display: grid;
        grid-template-columns: minmax(0, 1fr);
        gap: 1.5rem;
        max-width: 1200px;
        margin: 0 auto;
      }
      header.hero {
        background: rgba(15, 23, 42, 0.8);
        border-radius: 22px;
        padding: clamp(1.5rem, 4vw, 2.75rem);
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.65);
        border: 1px solid rgba(99, 102, 241, 0.4);
      }
      .hero-brand {
        display: flex;
        align-items: center;
        gap: 1.25rem;
        flex-wrap: wrap;
        margin-bottom: 1.5rem;
      }
      .brand-mark {
        width: clamp(90px, 12vw, 150px);
        height: clamp(90px, 12vw, 150px);
        border-radius: 22px;
        background: rgba(2, 6, 23, 0.8);
        border: 1px solid rgba(148, 163, 184, 0.35);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: clamp(0.5rem, 1vw, 1rem);
        box-shadow: inset 0 0 20px rgba(2, 6, 23, 0.65);
        overflow: hidden;
      }
      .brand-mark img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
        transform: scale(1.15);
      }
      header.hero h1 {
        margin: 0 0 0.5rem;
        font-size: clamp(2rem, 6vw, 3.1rem);
      }
      .hero-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-top: 1.25rem;
      }
      .stat-card {
        flex: 1 1 160px;
        border-radius: 18px;
        padding: 1rem;
        background: rgba(30, 41, 59, 0.65);
        border: 1px solid rgba(99, 102, 241, 0.3);
      }
      .stat-card strong {
        display: block;
        font-size: 2rem;
      }
      .filters-panel {
        background: rgba(15, 23, 42, 0.75);
        border-radius: 18px;
        padding: 1.25rem;
        border: 1px solid rgba(148, 163, 184, 0.18);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .filters-panel label {
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 0.8rem;
        color: #94a3b8;
      }
      .search-input {
        width: 100%;
        padding: 0.9rem 1rem;
        border-radius: 14px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(15, 23, 42, 0.6);
        color: inherit;
        font-size: 1rem;
      }
      .chip-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .chip {
        border: 1px solid rgba(148, 163, 184, 0.4);
        border-radius: 999px;
        padding: 0.35rem 0.85rem;
        font-size: 0.85rem;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease;
      }
      .chip.active {
        background: linear-gradient(120deg, #6366f1, #c084fc);
        color: #0f172a;
        border-color: transparent;
        font-weight: 600;
      }
      .sidebar button small {
        display: block;
        font-size: 0.7rem;
        color: #94a3b8;
      }
      .sidebar-actions {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .sidebar-actions button {
        width: 100%;
        border: 1px solid rgba(99, 102, 241, 0.5);
        border-radius: 12px;
        padding: 0.5rem 0.75rem;
        text-align: center;
        font-weight: 600;
      }
      .library-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 1.25rem;
      }
      .video-card {
        border-radius: 20px;
        overflow: hidden;
        border: 1px solid rgba(15, 23, 42, 0.6);
        background: rgba(15, 23, 42, 0.85);
        display: flex;
        flex-direction: column;
      }
      .video-header {
        padding: 1.25rem 1.25rem 0.35rem;
      }
      .video-header h3 {
        margin: 0 0 0.35rem;
        font-size: 1.15rem;
      }
      .video-header .video-meta {
        margin: 0;
      }
      .video-preview {
        position: relative;
        padding-top: 56.25%;
        background: rgba(30, 41, 59, 0.8);
        overflow: hidden;
      }
      .thumb {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
      }
      .thumb img {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .duration-badge {
        position: absolute;
        bottom: 0.75rem;
        right: 0.75rem;
        background: rgba(15, 23, 42, 0.85);
        padding: 0.25rem 0.5rem;
        border-radius: 999px;
        font-size: 0.75rem;
      }
      .card-player {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        border: none;
        display: none;
        background: black;
        border-radius: 0;
      }
      .video-card.playing .card-player {
        display: block;
      }
      .video-card.playing .thumb {
        display: none;
      }
      .favorite-toggle {
        position: absolute;
        top: 0.75rem;
        right: 0.75rem;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background: rgba(2, 6, 23, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fcd34d;
        cursor: pointer;
        display: grid;
        place-items: center;
        font-size: 1rem;
      }
      .favorite-toggle.active {
        background: rgba(250, 204, 21, 0.15);
        border-color: rgba(250, 204, 21, 0.6);
      }
      .video-body {
        padding: 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .video-meta {
        font-size: 0.85rem;
        color: #94a3b8;
      }
      .video-meta.tech-meta {
        color: #cbd5f5;
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
      }
      .tag-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
      }
      .tag {
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        padding: 0.2rem 0.65rem;
        font-size: 0.75rem;
      }
      .notes {
        font-size: 0.85rem;
        color: #cbd5f5;
        min-height: 2.4em;
      }
      .actions {
        margin-top: 0.5rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }
      .primary-button,
      .ghost-link,
      .info-button {
        border-radius: 12px;
        border: none;
        padding: 0.6rem 1.1rem;
        font-weight: 600;
        text-decoration: none;
        text-align: center;
        cursor: pointer;
      }
      .play-button {
        flex: 1;
        min-width: 160px;
      }
      .primary-button {
        background: linear-gradient(120deg, #f97316, #ec4899);
        color: white;
      }
      .info-button,
      .ghost-link {
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: transparent;
        color: inherit;
      }
      .info-button {
        flex: 1;
        min-width: 160px;
      }
      .download-menu {
        flex: 1;
        min-width: 220px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        border-radius: 12px;
        padding: 0.35rem 0.75rem;
        background: rgba(2, 6, 23, 0.4);
      }
      .download-menu summary {
        font-weight: 600;
        cursor: pointer;
        list-style: none;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 0.75rem;
        color: #94a3b8;
      }
      .download-menu summary::-webkit-details-marker {
        display: none;
      }
      .download-menu[open] summary {
        color: #e2e8f0;
      }
      .download-menu-body {
        margin-top: 0.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .download-menu .format-select {
        width: 100%;
      }
      .download-menu .menu-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .player-actions {
        margin-top: 1.5rem;
        display: flex;
        justify-content: flex-end;
      }
      .danger-button {
        background: #b91c1c;
        border: none;
        color: #fff;
        padding: 0.6rem 1.5rem;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: opacity 0.2s ease, transform 0.2s ease;
      }
      .danger-button:hover:not(:disabled) {
        opacity: 0.9;
        transform: translateY(-1px);
      }
      .danger-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }
      .format-select {
        flex: 1;
        min-width: 150px;
        padding: 0.5rem 0.75rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(15, 23, 42, 0.4);
        color: inherit;
      }
      .status-row {
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 0.5rem;
        font-size: 0.9rem;
        color: #94a3b8;
      }
      .hint {
        font-size: 0.85rem;
        color: #94a3b8;
        margin: 0.25rem 0 0;
      }
      .empty-state {
        text-align: center;
        padding: 3rem 1rem;
        border-radius: 18px;
        border: 1px dashed rgba(148, 163, 184, 0.4);
        color: #94a3b8;
      }
      @media (min-width: 1100px) {
        .app-shell {
          grid-template-columns: 280px minmax(0, 1fr);
        }
        .sidebar {
          position: sticky;
          top: 1rem;
          align-self: flex-start;
        }
      }
      .sidebar {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .sidebar section {
        background: rgba(15, 23, 42, 0.75);
        border-radius: 18px;
        padding: 1.25rem;
        border: 1px solid rgba(148, 163, 184, 0.18);
      }
      .sidebar h2 {
        margin: 0 0 0.5rem;
        font-size: 1rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #a5b4fc;
      }
      .sidebar ul {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .sidebar button {
        background: transparent;
        border: none;
        color: inherit;
        text-align: left;
        padding: 0.35rem 0.25rem;
        border-radius: 8px;
        cursor: pointer;
      }
      .sidebar button.active {
        color: #c084fc;
      }
      nav.top-nav {
        max-width: 1200px;
        margin: 0 auto 1.5rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1.5rem;
        border-radius: 18px;
        background: rgba(15, 23, 42, 0.85);
        border: 1px solid rgba(99, 102, 241, 0.3);
      }
      .brand {
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.15em;
      }
      .nav-links {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        align-items: center;
      }
      .nav-links a,
      .nav-links button {
        border: none;
        border-radius: 999px;
        padding: 0.4rem 0.9rem;
        background: rgba(99, 102, 241, 0.15);
        color: #e2e8f0;
        text-decoration: none;
        font-weight: 600;
        cursor: pointer;
      }
      .nav-links button {
        background: rgba(236, 72, 153, 0.2);
      }
      .modal {
        position: fixed;
        inset: 0;
        background: rgba(2, 6, 23, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 1rem;
        z-index: 20;
      }
      .modal.open {
        display: flex;
      }
      .modal-content {
        max-width: 900px;
        width: 100%;
        background: rgba(15, 23, 42, 0.95);
        border-radius: 20px;
        padding: 1.5rem;
        border: 1px solid rgba(99, 102, 241, 0.35);
        max-height: 90vh;
        overflow-y: auto;
      }
      .modal-content.player-modal {
        max-width: 1100px;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }
      .modal-body {
        margin-top: 1rem;
        display: grid;
        gap: 1rem;
      }
      .modal-close {
        background: transparent;
        border: none;
        color: inherit;
        font-size: 1.5rem;
        cursor: pointer;
      }
      .manager-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 1rem;
      }
      .manager-card {
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 16px;
        padding: 1rem;
        background: rgba(2, 6, 23, 0.7);
      }
      .manager-card form {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .manager-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .manager-list li {
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 14px;
        padding: 0.75rem;
        display: flex;
        justify-content: space-between;
        gap: 1rem;
        align-items: flex-start;
      }
      .manager-list button {
        border: none;
        background: rgba(239, 68, 68, 0.2);
        color: #fecaca;
        border-radius: 10px;
        padding: 0.35rem 0.75rem;
        cursor: pointer;
      }
      .category-row {
        display: grid;
        grid-template-columns: 1fr 200px 120px;
        gap: 0.75rem;
        align-items: center;
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 12px;
        padding: 0.75rem;
      }
      .category-row small {
        display: block;
        color: #94a3b8;
        margin-top: 0.15rem;
      }
      .category-row label {
        display: flex;
        align-items: center;
        gap: 0.35rem;
        font-size: 0.85rem;
        text-transform: none;
        letter-spacing: normal;
        color: #e2e8f0;
      }
      .manager-actions {
        display: flex;
        justify-content: flex-end;
        margin-top: 1rem;
      }
      .manager-actions button {
        border: none;
        border-radius: 12px;
        padding: 0.65rem 1.25rem;
        background: linear-gradient(120deg, #22d3ee, #6366f1);
        color: #0f172a;
        font-weight: 700;
        cursor: pointer;
      }
      .player-preview {
        background: rgba(2, 6, 23, 0.8);
        border-radius: 18px;
        overflow: hidden;
        border: 1px solid rgba(148, 163, 184, 0.25);
      }
      .player-preview video {
        width: 100%;
        display: block;
        background: black;
        border-radius: inherit;
      }
      .player-title {
        margin: 0;
        font-size: clamp(1.5rem, 4vw, 2.5rem);
      }
      .player-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        color: #94a3b8;
        font-size: 0.95rem;
      }
      .player-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
      }
      .player-tags .tag {
        border-color: rgba(148, 163, 184, 0.5);
      }
      .player-notes {
        font-size: 0.95rem;
        color: #e2e8f0;
        margin: 0;
      }
      .edit-form {
        display: grid;
        gap: 0.65rem;
        margin-top: 0.75rem;
      }
      .edit-form label {
        font-size: 0.8rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #94a3b8;
      }
      .edit-form input,
      .edit-form textarea,
      .edit-form select {
        width: 100%;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.6);
        color: inherit;
        padding: 0.75rem 0.9rem;
        font-size: 1rem;
      }
      .edit-form textarea {
        min-height: 100px;
        resize: vertical;
      }
      .edit-actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        align-items: center;
      }
      .status.inline {
        margin: 0;
      }
      .metadata-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 0.85rem;
      }
      .metadata-grid dt {
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #94a3b8;
        margin-bottom: 0.2rem;
      }
      .metadata-grid dd {
        margin: 0;
        font-size: 0.95rem;
        color: #e2e8f0;
        word-break: break-word;
      }
      .player-sections h3 {
        margin-bottom: 0.5rem;
      }
      .version-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.2rem 0.6rem;
        border-radius: 999px;
        background: rgba(99, 102, 241, 0.18);
        color: #c7d2fe;
        font-size: 0.85rem;
        border: 1px solid rgba(99, 102, 241, 0.35);
      }
    </style>
  </head>
  <body>
    <nav class="top-nav">
      <span class="brand">
        {{ app_name }}
        {% if videorama_version %}
        <span class="version-pill">v{{ videorama_version }}</span>
        {% endif %}
      </span>
      <div class="nav-links">
        <a href="/">Biblioteca</a>
        <a href="/external-player">Player externo</a>
        <a href="/import">Importador</a>
        <a href="/stats">Estadísticas</a>
        <button type="button" data-open-modal="playlist-modal">Playlists</button>
        <button type="button" data-open-modal="category-modal">Categorías</button>
      </div>
    </nav>
    <div class="app-shell">
      <aside class="sidebar">
        <section>
          <h2>Categorías</h2>
          <div class="chip-group" id="category-chips"></div>
        </section>
        <section>
          <h2>Listas estáticas</h2>
          <ul id="static-playlists"></ul>
        </section>
        <section>
          <h2>Listas dinámicas</h2>
          <ul id="dynamic-playlists"></ul>
        </section>
        <div class="sidebar-actions">
          <button type="button" data-open-modal="playlist-modal">Gestionar playlists</button>
          <button type="button" data-open-modal="category-modal">Gestionar categorías</button>
        </div>
      </aside>
      <main>
        <header class="hero">
          <div class="hero-brand">
            <div class="brand-mark">
              <img src="/assets/LogoVideorama.png" alt="Logotipo de Videorama" loading="lazy" />
            </div>
            <div>
              <h1>
                {{ app_name }}
                {% if videorama_version %}
                <span class="version-pill">v{{ videorama_version }}</span>
                {% endif %}
              </h1>
              <p>
                Biblioteca retro con {{ library_count }} elementos ya clasificados.
                {% if preview_categories %}Destacan: {{ ', '.join(preview_categories) }}.{% endif %}
              </p>
            </div>
          </div>
          <div class="hero-grid">
            <article class="stat-card">
              <label>Elementos</label>
              <strong>{{ '{:,}'.format(library_count).replace(',', '.') }}</strong>
              <small>Videos y audios listos para descargar.</small>
            </article>
            <article class="stat-card">
              <label>Favoritos</label>
              <strong id="favorite-count">0</strong>
              <small>Se guardan en tu navegador.</small>
            </article>
            <article class="stat-card">
              <label>Listas activas</label>
              <strong id="playlist-count">0</strong>
              <small>Estáticas + dinámicas.</small>
            </article>
          </div>
        </header>
        <section class="filters-panel">
          <div>
            <label for="search">Buscar</label>
            <input
              type="search"
              id="search"
              class="search-input"
              placeholder="Título, autor, etiqueta o nota"
              autocomplete="off"
            />
          </div>
          <div class="status-row">
            <p id="active-playlist">Mostrando toda la biblioteca.</p>
            <p id="results-counter">0 resultados.</p>
          </div>
        </section>
        <section id="library-section">
          <div class="library-grid" id="library-grid"></div>
          <div class="empty-state" id="empty-state" hidden>
            Nada coincide con tu búsqueda o filtros. Intenta otra combinación o vuelve a "Todos".
          </div>
        </section>
      </main>
    </div>
    <div class="modal" id="playlist-modal" aria-hidden="true">
      <div class="modal-content">
        <header class="modal-header">
          <div>
            <h2>Gestor de playlists</h2>
            <p class="hint">Crea listas estáticas con tu selección o define búsquedas automáticas.</p>
          </div>
          <button class="modal-close" type="button" data-close-modal>&times;</button>
        </header>
        <div class="modal-body">
          <div class="manager-grid">
            <article class="manager-card">
              <h3>Lista estática</h3>
              <form id="static-playlist-form">
                <label for="static-playlist-name">Nombre</label>
                <input id="static-playlist-name" required maxlength="80" />
                <label for="static-playlist-description">Descripción</label>
                <textarea id="static-playlist-description" maxlength="200"></textarea>
                <p class="hint">Se guardarán los vídeos visibles actualmente en la cuadrícula.</p>
                <button type="submit">Guardar selección actual</button>
                <p class="status" id="static-playlist-status"></p>
              </form>
            </article>
            <article class="manager-card">
              <h3>Lista dinámica</h3>
              <form id="dynamic-playlist-form">
                <label for="dynamic-playlist-name">Nombre</label>
                <input id="dynamic-playlist-name" required maxlength="80" />
                <label for="dynamic-playlist-description">Descripción</label>
                <textarea id="dynamic-playlist-description" maxlength="200"></textarea>
                <label for="dynamic-rule-type">Tipo de regla</label>
                <select id="dynamic-rule-type">
                  <option value="tag">Etiqueta</option>
                  <option value="category">Categoría</option>
                  <option value="uploader">Autor</option>
                  <option value="duration_min">Duración mínima (minutos)</option>
                  <option value="duration_max">Duración máxima (minutos)</option>
                </select>
                <label for="dynamic-rule-term">Valor o término</label>
                <input id="dynamic-rule-term" placeholder="Etiqueta, categoría o autor" />
                <label for="dynamic-rule-minutes">Minutos (si aplica)</label>
                <input id="dynamic-rule-minutes" type="number" min="1" step="1" />
                <button type="submit">Crear lista dinámica</button>
                <p class="status" id="dynamic-playlist-status"></p>
              </form>
            </article>
          </div>
          <section>
            <h3>Listas personalizadas</h3>
            <ul class="manager-list" id="custom-playlists"></ul>
          </section>
        </div>
      </div>
    </div>
    <div class="modal" id="category-modal" aria-hidden="true">
      <div class="modal-content">
        <header class="modal-header">
          <div>
            <h2>Gestor de categorías</h2>
            <p class="hint">Renombra o esconde categorías sin perder el material original.</p>
          </div>
          <button class="modal-close" type="button" data-close-modal>&times;</button>
        </header>
        <div class="modal-body">
          <form id="category-settings-form">
            <div class="manager-list" id="category-manager-list"></div>
            <div class="manager-actions">
              <button type="submit">Guardar preferencias</button>
            </div>
            <p class="status" id="category-manager-status"></p>
          </form>
        </div>
      </div>
    </div>
    <div class="modal" id="player-modal" aria-hidden="true">
      <div class="modal-content player-modal">
        <header class="modal-header">
          <div>
            <p class="eyebrow">Reproductor web</p>
            <h2 class="player-title" id="player-title">Videorama</h2>
          </div>
          <button class="modal-close" type="button" data-close-modal>&times;</button>
        </header>
        <div class="player-meta">
          <span id="player-uploader"></span>
          <span id="player-category"></span>
          <span id="player-duration"></span>
        </div>
        <div class="player-preview">
          <video id="player-video" controls preload="metadata" poster=""></video>
        </div>
        <p class="player-notes" id="player-notes"></p>
        <div class="player-tags" id="player-tags"></div>
        <section class="player-sections">
          <h3>Editar información</h3>
          <form id="player-edit-form" class="edit-form">
            <div>
              <label for="edit-title">Título</label>
              <input id="edit-title" name="title" maxlength="300" />
            </div>
            <div>
              <label for="edit-category">Categoría</label>
              <input id="edit-category" name="category" maxlength="120" />
            </div>
            <div>
              <label for="edit-tags">Etiquetas (separadas por comas)</label>
              <input id="edit-tags" name="tags" />
            </div>
            <div>
              <label for="edit-notes">Descripción o notas</label>
              <textarea id="edit-notes" name="notes" maxlength="2000"></textarea>
            </div>
            <div class="edit-actions">
              <button class="ghost-link" type="button" id="auto-tags-button">Sugerir etiquetas</button>
              <button class="ghost-link" type="button" id="auto-summary-button">Sugerir descripción</button>
              <p class="status inline" id="edit-status"></p>
            </div>
            <button class="primary-button" type="submit">Guardar cambios</button>
          </form>
        </section>
        <section class="player-sections">
          <h3>Ficha técnica</h3>
          <dl class="metadata-grid" id="player-facts"></dl>
        </section>
        <section class="player-sections">
          <h3>Metadatos originales</h3>
          <dl class="metadata-grid" id="player-metadata"></dl>
        </section>
        <details class="download-menu" id="player-download-menu">
          <summary>Descargas y recodificación</summary>
          <div class="download-menu-body">
            <label for="player-format">Formato de descarga</label>
            <select class="format-select" id="player-format"></select>
            <div class="menu-actions">
              <a class="primary-button" id="player-download" target="_blank" rel="noreferrer">Descargar</a>
              <a class="ghost-link" id="player-source" target="_blank" rel="noreferrer">Ver origen</a>
            </div>
          </div>
        </details>
        <div class="player-actions">
          <button class="danger-button" id="player-delete" type="button">Eliminar video</button>
        </div>
      </div>
    </div>

    <script>
      const DEFAULT_FORMAT = {{ default_format | tojson }};
      const libraryState = {
        entries: [],
        filtered: [],
        favorites: new Set(),
        categories: [],
        categoryStats: [],
        categorySettings: [],
        activeCategory: 'all',
        activePlaylistId: null,
        playlists: [],
        customPlaylists: [],
        search: '',
      };
      const playerState = { currentEntry: null };
      const playerElements = {};

      const STATIC_PLAYLISTS = [
        {
          id: 'recent',
          name: 'Últimos estrenos',
          description: 'Lo más nuevo añadido a la biblioteca.',
          category: 'static',
          source: 'system',
          resolve: (items) =>
            items
              .slice()
              .sort((a, b) => (b.added_at || 0) - (a.added_at || 0))
              .slice(0, 12),
        },
        {
          id: 'longform',
          name: 'Sesión de sofá',
          description: 'Vídeos de más de 15 minutos para maratones caseras.',
          category: 'static',
          source: 'system',
          resolve: (items) => items.filter((item) => (item.duration || 0) >= 900),
        },
        {
          id: 'clips',
          name: 'Clips exprés',
          description: 'Duración inferior a 3 minutos.',
          category: 'static',
          source: 'system',
          resolve: (items) => items.filter((item) => (item.duration || 0) > 0 && item.duration <= 180),
        },
        {
          id: 'random',
          name: 'Zapping retro',
          description: 'Selección aleatoria para descubrir joyas olvidadas.',
          category: 'static',
          source: 'system',
          resolve: (items) => shuffle(items).slice(0, 9),
        },
      ];

      document.addEventListener('DOMContentLoaded', init);

      async function init() {
        restoreFavorites();
        attachSearch();
        attachMenuButtons();
        setupPlayerUI();
        setupManagerForms();
        try {
          await Promise.all([fetchLibrary(), fetchCustomPlaylists(), fetchCategorySettings()]);
          buildCategories();
          buildPlaylists();
          applyFilters();
          renderPlaylistManager();
          renderCategoryManager();
        } catch (error) {
          showLibraryError(error.message);
        }
      }

      function fetchLibrary() {
        return fetch('/api/library')
          .then((response) => {
            if (!response.ok) {
              throw new Error('No se pudo cargar la biblioteca.');
            }
            return response.json();
          })
          .then((payload) => {
            libraryState.entries = Array.isArray(payload.items) ? payload.items : [];
          });
      }

      function fetchCustomPlaylists() {
        return fetch('/api/playlists')
          .then((response) => {
            if (!response.ok) {
              throw new Error('No se pudieron cargar las playlists personalizadas.');
            }
            return response.json();
          })
          .then((payload) => {
            libraryState.customPlaylists = Array.isArray(payload.items) ? payload.items : [];
          });
      }

      function fetchCategorySettings() {
        return fetch('/api/category-settings')
          .then((response) => {
            if (!response.ok) {
              throw new Error('No se pudieron cargar las categorías personalizadas.');
            }
            return response.json();
          })
          .then((payload) => {
            libraryState.categorySettings = Array.isArray(payload.settings) ? payload.settings : [];
          });
      }

      function showLibraryError(message) {
        const grid = document.getElementById('library-grid');
        grid.innerHTML = `<p class="empty-state">${message}</p>`;
      }

      function restoreFavorites() {
        try {
          const raw = localStorage.getItem('videorama:favorites');
          if (raw) {
            const parsed = JSON.parse(raw);
            if (Array.isArray(parsed)) {
              libraryState.favorites = new Set(parsed);
            }
          }
        } catch (error) {
          console.warn('No se pudieron restaurar favoritos', error);
        }
        updateFavoriteCounter();
      }

      function persistFavorites() {
        localStorage.setItem('videorama:favorites', JSON.stringify([...libraryState.favorites]));
        updateFavoriteCounter();
        buildCategories();
      }

      function updateFavoriteCounter() {
        const counter = document.getElementById('favorite-count');
        counter.textContent = libraryState.favorites.size;
      }

      function attachSearch() {
        const searchInput = document.getElementById('search');
        searchInput.addEventListener('input', (event) => {
          libraryState.search = event.target.value.toLowerCase();
          applyFilters();
        });
      }

      function attachMenuButtons() {
        document.querySelectorAll('[data-open-modal]').forEach((button) => {
          button.addEventListener('click', () => openModal(button.getAttribute('data-open-modal')));
        });
        document.querySelectorAll('[data-close-modal]').forEach((button) => {
          button.addEventListener('click', () => closeModal(button.closest('.modal')));
        });
        document.querySelectorAll('.modal').forEach((modal) => {
          modal.addEventListener('click', (event) => {
            if (event.target === modal) {
              closeModal(modal);
            }
          });
        });
        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            document.querySelectorAll('.modal.open').forEach((modal) => closeModal(modal));
          }
        });
      }

      function setupPlayerUI() {
        playerElements.modal = document.getElementById('player-modal');
        if (!playerElements.modal) {
          return;
        }
        playerElements.video = document.getElementById('player-video');
        playerElements.title = document.getElementById('player-title');
        playerElements.uploader = document.getElementById('player-uploader');
        playerElements.category = document.getElementById('player-category');
        playerElements.duration = document.getElementById('player-duration');
        playerElements.notes = document.getElementById('player-notes');
        playerElements.tags = document.getElementById('player-tags');
        playerElements.editForm = document.getElementById('player-edit-form');
        playerElements.editTitle = document.getElementById('edit-title');
        playerElements.editCategory = document.getElementById('edit-category');
        playerElements.editTags = document.getElementById('edit-tags');
        playerElements.editNotes = document.getElementById('edit-notes');
        playerElements.editStatus = document.getElementById('edit-status');
        playerElements.autoTagsButton = document.getElementById('auto-tags-button');
        playerElements.autoSummaryButton = document.getElementById('auto-summary-button');
        playerElements.metadata = document.getElementById('player-metadata');
        playerElements.facts = document.getElementById('player-facts');
        playerElements.formatSelect = document.getElementById('player-format');
        playerElements.downloadLink = document.getElementById('player-download');
        playerElements.sourceLink = document.getElementById('player-source');
        playerElements.downloadMenu = document.getElementById('player-download-menu');
        playerElements.deleteButton = document.getElementById('player-delete');
        if (playerElements.formatSelect) {
          playerElements.formatSelect.addEventListener('change', updatePlayerDownloadLink);
        }
        if (playerElements.deleteButton) {
          playerElements.deleteButton.addEventListener('click', handlePlayerDelete);
        }
        if (playerElements.editForm) {
          playerElements.editForm.addEventListener('submit', handlePlayerUpdate);
        }
        if (playerElements.autoTagsButton) {
          playerElements.autoTagsButton.addEventListener('click', handleAutoTags);
        }
        if (playerElements.autoSummaryButton) {
          playerElements.autoSummaryButton.addEventListener('click', handleAutoSummary);
        }
      }

      function openPlayer(entry) {
        if (!playerElements.modal) {
          return;
        }
        playerState.currentEntry = entry;
        if (playerElements.title) {
          playerElements.title.textContent = entry.title || 'Sin título';
        }
        if (playerElements.uploader) {
          playerElements.uploader.textContent = entry.uploader ? `Autor: ${entry.uploader}` : 'Autor desconocido';
        }
        if (playerElements.category) {
          playerElements.category.textContent = `Categoría: ${toTitle(entry.category || 'miscelánea')}`;
        }
        if (playerElements.duration) {
          playerElements.duration.textContent = `Duración: ${formatDuration(entry.duration)}`;
        }
        if (playerElements.notes) {
          playerElements.notes.textContent = entry.notes || 'Sin notas adicionales.';
        }
        populateEditForm(entry);
        renderTagChips(playerElements.tags, entry.tags || []);
        renderFactList(entry);
        renderMetadata(entry.metadata);
        if (playerElements.sourceLink) {
          playerElements.sourceLink.href = entry.url;
        }
        if (playerElements.downloadMenu) {
          playerElements.downloadMenu.open = false;
        }
        if (playerElements.deleteButton) {
          playerElements.deleteButton.disabled = false;
          playerElements.deleteButton.textContent = 'Eliminar video';
        }
        const streamUrl = buildStreamUrl(entry, entry.preferred_format || DEFAULT_FORMAT);
        if (playerElements.video) {
          playerElements.video.src = streamUrl;
          playerElements.video.poster = entry.thumbnail || '';
          playerElements.video.load();
        }
        if (playerElements.formatSelect) {
          playerElements.formatSelect.innerHTML = formatOptions(entry.preferred_format || DEFAULT_FORMAT)
            .map((option) => `<option value="${option.value}" ${option.selected ? 'selected' : ''}>${option.label}</option>`)
            .join('');
        }
        updatePlayerDownloadLink();
        openModal('player-modal');
      }

      function renderTagChips(container, tags) {
        if (!container) {
          return;
        }
        container.innerHTML = '';
        const cleaned = (tags || []).filter(Boolean);
        if (!cleaned.length) {
          const hint = document.createElement('span');
          hint.className = 'hint';
          hint.textContent = 'Sin etiquetas registradas.';
          container.appendChild(hint);
          return;
        }
        cleaned.slice(0, 8).forEach((tag) => {
          const chip = document.createElement('span');
          chip.className = 'tag';
          chip.textContent = tag;
          container.appendChild(chip);
        });
      }

      function renderFactList(entry) {
        if (!playerElements.facts) {
          return;
        }
        const facts = [
          { label: 'Categoría', value: toTitle(entry.category || 'miscelánea') },
          { label: 'Autor', value: entry.uploader || 'Desconocido' },
          { label: 'Duración', value: formatDuration(entry.duration) },
          { label: 'Extractor', value: entry.extractor || '—' },
          { label: 'Resolución', value: inferResolutionFromMetadata(entry.metadata) || '—' },
          { label: 'Códecs', value: inferCodecsFromMetadata(entry.metadata) || '—' },
          {
            label: 'Tamaño',
            value: inferSizeFromMetadata(entry.metadata) ? formatFileSize(inferSizeFromMetadata(entry.metadata)) : '—',
          },
          { label: 'Etiquetas', value: (entry.tags || []).join(', ') || '—' },
          { label: 'Añadido', value: formatDate(entry.added_at) },
        ];
        renderDefinitionList(playerElements.facts, facts, 'Sin ficha disponible.');
      }

      function renderMetadata(metadata) {
        if (!playerElements.metadata) {
          return;
        }
        const normalized = metadata && !Array.isArray(metadata) && typeof metadata === 'object' ? metadata : {};
        const prioritized = [];
        if (Array.isArray(normalized.tags) && normalized.tags.length) {
          prioritized.push({ label: 'Etiquetas originales', value: metadataValueToString(normalized.tags) });
        }
        const remaining = Object.entries(normalized)
          .filter(([label]) => label !== 'tags')
          .slice(0, Math.max(0, 10 - prioritized.length))
          .map(([label, value]) => ({ label, value: metadataValueToString(value) }));
        renderDefinitionList(
          playerElements.metadata,
          [...prioritized, ...remaining],
          'Sin metadatos disponibles.',
        );
      }

      function renderDefinitionList(container, items, emptyMessage) {
        if (!container) {
          return;
        }
        container.innerHTML = '';
        if (!items.length) {
          const empty = document.createElement('p');
          empty.className = 'hint';
          empty.textContent = emptyMessage || 'Sin datos disponibles.';
          container.appendChild(empty);
          return;
        }
        items.forEach(({ label, value }) => {
          const dt = document.createElement('dt');
          dt.textContent = label;
          const dd = document.createElement('dd');
          dd.textContent = value;
          container.appendChild(dt);
          container.appendChild(dd);
        });
      }

      function metadataValueToString(value) {
        if (value === null || value === undefined) {
          return '—';
        }
        if (Array.isArray(value)) {
          return value
            .map((item) => metadataValueToString(item))
            .filter(Boolean)
            .slice(0, 5)
            .join(', ');
        }
        if (typeof value === 'object') {
          try {
            const serialized = JSON.stringify(value);
            return serialized.length > 140 ? `${serialized.slice(0, 140)}…` : serialized;
          } catch (error) {
            console.warn('No se pudo serializar metadato', error);
            return '[objeto]';
          }
        }
        return String(value);
      }

      function formatDate(timestamp) {
        if (!timestamp) {
          return '—';
        }
        try {
          return new Date(timestamp * 1000).toLocaleString('es-ES');
        } catch (error) {
          return '—';
        }
      }

      function updatePlayerDownloadLink() {
        if (!playerElements.formatSelect || !playerElements.downloadLink || !playerState.currentEntry) {
          return;
        }
        const format = playerElements.formatSelect.value || playerState.currentEntry.preferred_format || DEFAULT_FORMAT;
        const href = buildDownloadUrl(playerState.currentEntry, format);
        playerElements.downloadLink.href = href;
      }

      function populateEditForm(entry) {
        if (!playerElements.editForm) {
          return;
        }
        if (playerElements.editTitle) {
          playerElements.editTitle.value = entry.title || '';
        }
        if (playerElements.editCategory) {
          playerElements.editCategory.value = entry.category || '';
        }
        if (playerElements.editTags) {
          playerElements.editTags.value = (entry.tags || []).join(', ');
        }
        if (playerElements.editNotes) {
          playerElements.editNotes.value = entry.notes || '';
        }
        setEditStatus('');
      }

      function parseTagInput(raw) {
        if (!raw) {
          return [];
        }
        const parts = raw
          .split(',')
          .map((part) => part.trim())
          .filter(Boolean);
        return [...new Set(parts)];
      }

      function setEditStatus(message) {
        if (playerElements.editStatus) {
          playerElements.editStatus.textContent = message || '';
        }
      }

      async function handlePlayerUpdate(event) {
        event.preventDefault();
        if (!playerState.currentEntry || !playerElements.editForm) {
          return;
        }
        const title = playerElements.editTitle ? playerElements.editTitle.value.trim() : undefined;
        const category = playerElements.editCategory ? playerElements.editCategory.value.trim() : undefined;
        const notesValue = playerElements.editNotes ? playerElements.editNotes.value.trim() : undefined;
        const tagsValue = playerElements.editTags ? playerElements.editTags.value : '';
        const payload = {
          title: title === undefined ? undefined : title || null,
          category: category === undefined ? undefined : category || null,
          notes: notesValue === undefined ? undefined : notesValue || null,
          tags: parseTagInput(tagsValue),
        };
        setEditStatus('Guardando cambios…');
        try {
          const response = await fetch(`/api/library/${playerState.currentEntry.id}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(result.detail || 'No se pudo actualizar el video.');
          }
          updateEntryInLibrary(result);
          playerState.currentEntry = result;
          openPlayer(result);
          applyFilters();
          setEditStatus('Cambios guardados.');
        } catch (error) {
          console.error(error);
          setEditStatus(error.message || 'No se pudo guardar.');
        }
      }

      async function handleAutoTags() {
        if (!playerState.currentEntry) {
          return;
        }
        setEditStatus('Generando etiquetas…');
        try {
          const response = await fetch('/api/import/auto-tags', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              url: playerState.currentEntry.url,
              title: playerElements.editTitle?.value || playerState.currentEntry.title,
              notes: playerElements.editNotes?.value || playerState.currentEntry.notes,
              metadata: playerState.currentEntry.metadata || {},
              prefer_transcription: true,
            }),
          });
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(result.detail || 'No se pudieron sugerir etiquetas.');
          }
          if (playerElements.editTags) {
            playerElements.editTags.value = (result.tags || []).join(', ');
          }
          setEditStatus('Etiquetas sugeridas listas.');
        } catch (error) {
          console.error(error);
          setEditStatus(error.message || 'No se pudieron obtener etiquetas.');
        }
      }

      async function handleAutoSummary() {
        if (!playerState.currentEntry) {
          return;
        }
        setEditStatus('Generando descripción…');
        try {
          const response = await fetch('/api/import/auto-summary', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              url: playerState.currentEntry.url,
              title: playerElements.editTitle?.value || playerState.currentEntry.title,
              notes: playerElements.editNotes?.value || playerState.currentEntry.notes,
              metadata: playerState.currentEntry.metadata || {},
              prefer_transcription: true,
            }),
          });
          const result = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(result.detail || 'No se pudo sugerir la descripción.');
          }
          if (playerElements.editNotes && result.summary) {
            playerElements.editNotes.value = result.summary;
          }
          setEditStatus('Descripción sugerida aplicada.');
        } catch (error) {
          console.error(error);
          setEditStatus(error.message || 'No se pudo generar la descripción.');
        }
      }

      async function handlePlayerDelete() {
        if (!playerElements.deleteButton || !playerState.currentEntry) {
          return;
        }
        const entry = playerState.currentEntry;
        const confirmed = window.confirm(
          `¿Seguro que deseas eliminar "${entry.title || 'este video'}" de la biblioteca? Esta acción no se puede deshacer.`,
        );
        if (!confirmed) {
          return;
        }
        const originalLabel = playerElements.deleteButton.textContent;
        playerElements.deleteButton.disabled = true;
        playerElements.deleteButton.textContent = 'Eliminando…';
        try {
          const response = await fetch(`/api/library/${entry.id}`, { method: 'DELETE' });
          const payload = await response.json().catch(() => ({}));
          if (!response.ok) {
            throw new Error(payload.detail || 'No se pudo eliminar el video.');
          }
          removeEntryFromLibrary(entry.id);
          stopPlayer();
          if (playerElements.modal) {
            closeModal(playerElements.modal);
          }
        } catch (error) {
          alert(error.message);
        } finally {
          playerElements.deleteButton.disabled = false;
          playerElements.deleteButton.textContent = originalLabel;
        }
      }

      function removeEntryFromLibrary(entryId) {
        if (!entryId) {
          return;
        }
        libraryState.entries = libraryState.entries.filter((item) => item.id !== entryId);
        libraryState.favorites.delete(entryId);
        buildCategories();
        buildPlaylists();
        applyFilters();
      }

      function updateEntryInLibrary(updatedEntry) {
        if (!updatedEntry?.id) {
          return;
        }
        libraryState.entries = libraryState.entries.map((item) =>
          item.id === updatedEntry.id ? { ...item, ...updatedEntry } : item,
        );
        libraryState.filtered = libraryState.filtered.map((item) =>
          item.id === updatedEntry.id ? { ...item, ...updatedEntry } : item,
        );
        buildCategories();
        buildPlaylists();
        updateFavoriteCounter();
      }

      function stopPlayer() {
        if (!playerElements.video) {
          return;
        }
        playerElements.video.pause();
        playerElements.video.removeAttribute('src');
        playerElements.video.load();
        playerState.currentEntry = null;
      }

      function setupManagerForms() {
        const staticForm = document.getElementById('static-playlist-form');
        const dynamicForm = document.getElementById('dynamic-playlist-form');
        const categoryForm = document.getElementById('category-settings-form');
        if (staticForm) {
          staticForm.addEventListener('submit', handleStaticPlaylistSubmit);
        }
        if (dynamicForm) {
          dynamicForm.addEventListener('submit', handleDynamicPlaylistSubmit);
        }
        if (categoryForm) {
          categoryForm.addEventListener('submit', handleCategorySettingsSubmit);
        }
      }

      function openModal(id) {
        const modal = document.getElementById(id);
        if (!modal) {
          return;
        }
        modal.classList.add('open');
        modal.setAttribute('aria-hidden', 'false');
      }

      function closeModal(modal) {
        if (!modal) {
          return;
        }
        modal.classList.remove('open');
        modal.setAttribute('aria-hidden', 'true');
        if (modal.id === 'player-modal') {
          stopPlayer();
        }
      }

      function buildCategories() {
        const categories = new Map();
        libraryState.entries.forEach((entry) => {
          const name = normalize(entry.category) || 'miscelánea';
          categories.set(name, (categories.get(name) || 0) + 1);
        });
        libraryState.categoryStats = [...categories.entries()].map(([slug, count]) => ({ slug, count }));
        const preferenceMap = new Map(libraryState.categorySettings.map((pref) => [pref.slug, pref]));
        preferenceMap.forEach((pref, slug) => {
          if (!categories.has(slug)) {
            libraryState.categoryStats.push({ slug, count: 0 });
          }
        });
        const chips = [
          { id: 'all', label: 'Todos', count: libraryState.entries.length },
          { id: 'favorites', label: 'Favoritos', count: libraryState.favorites.size },
        ];
        libraryState.categoryStats.forEach(({ slug, count }) => {
          const pref = preferenceMap.get(slug);
          if (pref?.hidden) {
            return;
          }
          const label = pref?.label?.trim() || toTitle(slug);
          chips.push({ id: slug, label, count });
        });
        libraryState.categories = chips;
        renderCategoryChips();
      }

      function renderCategoryChips() {
        const container = document.getElementById('category-chips');
        container.innerHTML = '';
        libraryState.categories.forEach((chip) => {
          const element = document.createElement('button');
          element.type = 'button';
          element.className = `chip ${libraryState.activeCategory === chip.id ? 'active' : ''}`;
          element.textContent = `${chip.label} (${chip.count})`;
          element.addEventListener('click', () => {
            libraryState.activeCategory = chip.id;
            libraryState.activePlaylistId = null;
            applyFilters();
          });
          container.appendChild(element);
        });
      }

      function buildPlaylists() {
        const auto = buildAutoPlaylists(libraryState.entries);
        const custom = buildCustomPlaylists(libraryState.customPlaylists);
        libraryState.playlists = [...STATIC_PLAYLISTS, ...auto, ...custom];
        const playlistCount = document.getElementById('playlist-count');
        playlistCount.textContent = libraryState.playlists.length;
        renderPlaylists();
      }

      function buildAutoPlaylists(items) {
        const categoryCounts = aggregateCounts(items.map((entry) => normalize(entry.category)));
        const topCategories = categoryCounts.slice(0, 4).map((cat) => ({
          id: `cat-${cat.value}`,
          name: `Categoría: ${toTitle(cat.value)}`,
          description: `${cat.count} piezas seleccionadas automáticamente.`,
          category: 'dynamic',
          source: 'system',
          resolve: (entries) => entries.filter((entry) => normalize(entry.category) === cat.value).slice(0, 12),
        }));

        const tagCounts = aggregateCounts(
          items
            .flatMap((entry) => (Array.isArray(entry.tags) ? entry.tags : []))
            .map((tag) => normalize(tag))
            .filter(Boolean),
        ).slice(0, 3);

        const tagPlaylists = tagCounts.map((tag) => ({
          id: `tag-${tag.value}`,
          name: `Etiqueta: ${toTitle(tag.value)}`,
          description: 'Agrupación dinámica según etiquetas coincidentes.',
          category: 'dynamic',
          source: 'system',
          resolve: (entries) =>
            entries.filter((entry) => (entry.tags || []).some((tagName) => normalize(tagName) === tag.value)).slice(0, 12),
        }));

        return [...topCategories, ...tagPlaylists];
      }

      function buildCustomPlaylists(items) {
        return items.map((playlist) => {
          if (playlist.mode === 'static') {
            const entryIds = playlist.config?.entry_ids || [];
            return {
              ...playlist,
              category: 'static',
              source: 'custom',
              resolve: (entries) => entries.filter((entry) => entryIds.includes(entry.id)),
            };
          }
          return {
            ...playlist,
            category: 'dynamic',
            source: 'custom',
            resolve: (entries) => applyCustomRule(entries, playlist.config?.rules || {}),
          };
        });
      }

      function applyCustomRule(entries, rules) {
        if (!rules || !rules.type) {
          return entries;
        }
        let results = entries;
        const term = normalize(rules.term);
        if (rules.type === 'tag' && term) {
          results = results.filter((entry) => (entry.tags || []).some((tag) => normalize(tag) === term));
        } else if (rules.type === 'category' && term) {
          results = results.filter((entry) => normalize(entry.category) === term);
        } else if (rules.type === 'uploader' && term) {
          results = results.filter((entry) => normalize(entry.uploader) === term);
        } else if (rules.type === 'duration_min' && Number.isFinite(Number(rules.minutes))) {
          const threshold = Number(rules.minutes) * 60;
          results = results.filter((entry) => (entry.duration || 0) >= threshold);
        } else if (rules.type === 'duration_max' && Number.isFinite(Number(rules.minutes))) {
          const threshold = Number(rules.minutes) * 60;
          results = results.filter((entry) => (entry.duration || 0) <= threshold);
        }
        return results.slice(0, 36);
      }

      function renderPlaylists() {
        const staticList = document.getElementById('static-playlists');
        const dynamicList = document.getElementById('dynamic-playlists');
        staticList.innerHTML = '';
        dynamicList.innerHTML = '';
        libraryState.playlists.forEach((playlist) => {
          const listItem = document.createElement('li');
          const button = document.createElement('button');
          button.type = 'button';
          button.className = libraryState.activePlaylistId === playlist.id ? 'active' : '';
          const badge = playlist.source === 'custom' ? 'Personalizada' : playlist.category === 'static' ? 'Lista fija' : 'Búsqueda';
          button.innerHTML = `${playlist.name}<small>${badge}</small>`;
          button.addEventListener('click', () => {
            libraryState.activePlaylistId = playlist.id;
            libraryState.activeCategory = 'all';
            applyFilters();
            renderPlaylists();
          });
          listItem.appendChild(button);
          if (playlist.category === 'static') {
            staticList.appendChild(listItem);
          } else {
            dynamicList.appendChild(listItem);
          }
        });
      }

      function applyFilters() {
        let items = [...libraryState.entries];
        if (libraryState.activePlaylistId) {
          const playlist = libraryState.playlists.find((pl) => pl.id === libraryState.activePlaylistId);
          if (playlist) {
            items = playlist.resolve(libraryState.entries);
          }
        } else if (libraryState.activeCategory === 'favorites') {
          items = items.filter((entry) => libraryState.favorites.has(entry.id));
        } else if (libraryState.activeCategory !== 'all') {
          items = items.filter((entry) => normalize(entry.category) === libraryState.activeCategory);
        }

        if (libraryState.search) {
          items = items.filter((entry) => {
            const haystack = [entry.title, entry.uploader, entry.notes, entry.category]
              .concat(entry.tags || [])
              .join(' ')
              .toLowerCase();
            return haystack.includes(libraryState.search);
          });
        }

        libraryState.filtered = items;
        renderLibrary(items);
        updateCounters();
      }

      function renderLibrary(items) {
        const grid = document.getElementById('library-grid');
        const emptyState = document.getElementById('empty-state');
        grid.innerHTML = '';
        if (!items.length) {
          emptyState.hidden = false;
          return;
        }
        emptyState.hidden = true;
        const fragment = document.createDocumentFragment();
        items.forEach((entry) => {
          fragment.appendChild(createVideoCard(entry));
        });
        grid.appendChild(fragment);
      }

      function createVideoCard(entry) {
        const preferredFormat = entry.preferred_format || DEFAULT_FORMAT;
        const downloadUrl = buildDownloadUrl(entry, preferredFormat);
        const card = document.createElement('article');
        card.className = 'video-card';
        card.innerHTML = `
          <div class="video-header">
            <h3>${entry.title}</h3>
            <p class="video-meta">${entry.uploader || 'Autor desconocido'} · ${toTitle(entry.category || 'miscelánea')}</p>
            <p class="video-meta tech-meta">${buildTechSummary(entry)}</p>
          </div>
          <div class="video-preview">
            <div class="thumb">
              <img src="${entry.thumbnail || 'https://placehold.co/640x360?text=Videorama'}" alt="Miniatura" loading="lazy" />
              <button class="favorite-toggle ${libraryState.favorites.has(entry.id) ? 'active' : ''}" title="Marcar como favorito">★</button>
              <span class="duration-badge">${formatDuration(entry.duration)}</span>
            </div>
            <video class="card-player" playsinline controls preload="metadata" poster="${entry.thumbnail || ''}"></video>
          </div>
          <div class="video-body">
            <div class="tag-row">
              ${(entry.tags || []).slice(0, 4).map((tag) => `<span class="tag">${tag}</span>`).join('')}
            </div>
            <p class="notes">${entry.notes || 'Sin notas adicionales.'}</p>
            <div class="actions">
              <button class="primary-button play-button" type="button">Reproducir</button>
              <button class="info-button" type="button">Más información</button>
              <details class="download-menu">
                <summary>Descargas y recodificación</summary>
                <div class="download-menu-body">
                  <select class="format-select">
                    ${formatOptions(preferredFormat)
                      .map((option) => `<option value="${option.value}" ${option.selected ? 'selected' : ''}>${option.label}</option>`)
                      .join('')}
                  </select>
                  <div class="menu-actions">
                    <a class="ghost-link download-link" href="${downloadUrl}" target="_blank" rel="noreferrer">Descargar</a>
                    <a class="ghost-link" href="${entry.url}" target="_blank" rel="noreferrer">Ver origen</a>
                  </div>
                </div>
              </details>
            </div>
          </div>
        `;
        const favoriteButton = card.querySelector('.favorite-toggle');
        favoriteButton.addEventListener('click', () => toggleFavorite(entry.id, favoriteButton));
        const select = card.querySelector('.download-menu .format-select');
        const downloadLink = card.querySelector('.download-link');
        select.addEventListener('change', () => {
          downloadLink.href = buildDownloadUrl(entry, select.value);
        });
        const playButton = card.querySelector('.play-button');
        const infoButton = card.querySelector('.info-button');
        const thumb = card.querySelector('.thumb');
        playButton.addEventListener('click', () => startInlinePlayback(entry, card));
        thumb.addEventListener('click', () => startInlinePlayback(entry, card));
        if (infoButton) {
          infoButton.addEventListener('click', () => openPlayer(entry));
        }
        return card;
      }

      function toggleFavorite(id, button) {
        if (libraryState.favorites.has(id)) {
          libraryState.favorites.delete(id);
          button.classList.remove('active');
        } else {
          libraryState.favorites.add(id);
          button.classList.add('active');
        }
        persistFavorites();
        if (libraryState.activeCategory === 'favorites') {
          applyFilters();
        } else {
          updateFavoriteCounter();
        }
      }

      function buildDownloadUrl(entry, format) {
        if (!entry || !entry.id) {
          return '#';
        }
        const params = new URLSearchParams();
        if (format) {
          params.set('format', format);
        }
        const query = params.toString();
        return `/api/library/${entry.id}/download${query ? `?${query}` : ''}`;
      }

      function buildStreamUrl(entry, format) {
        if (!entry || !entry.id) {
          return '';
        }
        const params = new URLSearchParams();
        if (format) {
          params.set('format', format);
        }
        const query = params.toString();
        return `/api/library/${entry.id}/stream${query ? `?${query}` : ''}`;
      }

      function resetInlinePlayer(card) {
        if (!card) {
          return;
        }
        card.classList.remove('playing');
        const player = card.querySelector('.card-player');
        const thumb = card.querySelector('.thumb');
        if (player) {
          player.pause();
          delete player.dataset.fallbackTried;
          player.removeAttribute('src');
          player.load();
        }
        if (thumb) {
          thumb.removeAttribute('aria-hidden');
        }
      }

      function startInlinePlayback(entry, card) {
        if (!card) {
          openPlayer(entry);
          return;
        }
        document.querySelectorAll('.video-card.playing').forEach((activeCard) => {
          if (activeCard !== card) {
            resetInlinePlayer(activeCard);
          }
        });
        const player = card.querySelector('.card-player');
        if (!player) {
          openPlayer(entry);
          return;
        }
        const thumb = card.querySelector('.thumb');
        card.classList.add('playing');
        if (thumb) {
          thumb.setAttribute('aria-hidden', 'true');
        }
        const primaryFormat = entry.preferred_format || DEFAULT_FORMAT;
        const fallbackFormat = primaryFormat === DEFAULT_FORMAT ? null : DEFAULT_FORMAT;
        const attemptPlayback = (formatToUse, isFallback = false) => {
          const sourceUrl = buildStreamUrl(entry, formatToUse);
          if (!sourceUrl) {
            resetInlinePlayer(card);
            openPlayer(entry);
            return;
          }
          player.src = sourceUrl;
          player.poster = entry.thumbnail || '';
          player.load();
          player
            .play()
            .catch((error) => {
              console.warn('No se pudo iniciar la reproducción inline', error);
              if (!isFallback && fallbackFormat) {
                attemptPlayback(fallbackFormat, true);
              } else {
                resetInlinePlayer(card);
                openPlayer(entry);
              }
            });
        };

        player.onerror = () => {
          if (player.dataset.fallbackTried) {
            resetInlinePlayer(card);
            openPlayer(entry);
            return;
          }
          player.dataset.fallbackTried = '1';
          if (fallbackFormat) {
            attemptPlayback(fallbackFormat, true);
          } else {
            resetInlinePlayer(card);
            openPlayer(entry);
          }
        };
        player.onended = () => {
          resetInlinePlayer(card);
        };
        attemptPlayback(primaryFormat);
      }

      function formatDuration(seconds) {
        if (!seconds) {
          return '—';
        }
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        if (mins >= 60) {
          const hours = Math.floor(mins / 60);
          const remMins = mins % 60;
          return `${hours.toString().padStart(2, '0')}:${remMins.toString().padStart(2, '0')}:${secs
            .toString()
            .padStart(2, '0')}`;
        }
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      }

      function formatFileSize(bytes) {
        if (!bytes || Number.isNaN(Number(bytes))) {
          return '';
        }
        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        let size = Number(bytes);
        let unitIndex = 0;
        while (size >= 1024 && unitIndex < units.length - 1) {
          size /= 1024;
          unitIndex += 1;
        }
        const formatted = size >= 10 || size % 1 === 0 ? size.toFixed(0) : size.toFixed(1);
        return `${formatted} ${units[unitIndex]}`;
      }

      function inferSizeFromMetadata(metadata) {
        if (!metadata || typeof metadata !== 'object') {
          return null;
        }
        const candidates = ['file_size', 'filesize', 'filesize_approx', 'approx_filesize'];
        for (const key of candidates) {
          const value = metadata[key];
          if (Number.isFinite(value) && value > 0) {
            return Number(value);
          }
        }
        const formats = metadata.requested_formats || metadata.formats || [];
        for (const fmt of formats) {
          if (!fmt || typeof fmt !== 'object') continue;
          if (Number.isFinite(fmt.filesize) && fmt.filesize > 0) {
            return Number(fmt.filesize);
          }
          if (Number.isFinite(fmt.filesize_approx) && fmt.filesize_approx > 0) {
            return Number(fmt.filesize_approx);
          }
        }
        return null;
      }

      function inferResolutionFromMetadata(metadata) {
        if (!metadata || typeof metadata !== 'object') {
          return '';
        }
        if (Number.isFinite(metadata.width) && Number.isFinite(metadata.height) && metadata.width > 0 && metadata.height > 0) {
          return `${Number(metadata.width)}x${Number(metadata.height)}`;
        }
        const resolution = metadata.resolution || metadata.format_note;
        if (resolution) {
          return `${resolution}`;
        }
        const formats = metadata.requested_formats || metadata.formats || [];
        for (const fmt of formats) {
          if (!fmt || typeof fmt !== 'object') continue;
          if (fmt.resolution) {
            return `${fmt.resolution}`;
          }
          if (Number.isFinite(fmt.width) && Number.isFinite(fmt.height)) {
            return `${fmt.width}x${fmt.height}`;
          }
        }
        return '';
      }

      function inferCodecsFromMetadata(metadata) {
        if (!metadata || typeof metadata !== 'object') {
          return '';
        }
        const codecs = [];
        const vcodec = metadata.vcodec || metadata.video_codec;
        const acodec = metadata.acodec || metadata.audio_codec;
        [vcodec, acodec].forEach((codec) => {
          if (codec && `${codec}`.toLowerCase() !== 'none') {
            codecs.push(codec);
          }
        });
        if (!codecs.length) {
          const formats = metadata.requested_formats || metadata.formats || [];
          for (const fmt of formats) {
            if (fmt?.vcodec && `${fmt.vcodec}`.toLowerCase() !== 'none') {
              codecs.push(fmt.vcodec);
            }
            if (fmt?.acodec && `${fmt.acodec}`.toLowerCase() !== 'none') {
              codecs.push(fmt.acodec);
            }
            if (codecs.length) break;
          }
        }
        return codecs.join(' / ');
      }

      function buildTechSummary(entry) {
        const details = [];
        const size = inferSizeFromMetadata(entry.metadata);
        const resolution = inferResolutionFromMetadata(entry.metadata);
        const codecs = inferCodecsFromMetadata(entry.metadata);
        const duration = formatDuration(entry.duration);
        if (duration && duration !== '—') {
          details.push(`Duración ${duration}`);
        }
        if (resolution) {
          details.push(resolution);
        }
        if (codecs) {
          details.push(codecs);
        }
        if (size) {
          details.push(formatFileSize(size));
        }
        return details.join(' • ') || 'Metadatos en preparación';
      }

      function normalize(value) {
        return (value || '')
          .toString()
          .trim()
          .toLowerCase();
      }

      function toTitle(value) {
        const normalized = normalize(value);
        if (!normalized) {
          return '';
        }
        return normalized.replace(/\w/g, (match) => match.toUpperCase());
      }

      function shuffle(items) {
        const copy = items.slice();
        for (let i = copy.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [copy[i], copy[j]] = [copy[j], copy[i]];
        }
        return copy;
      }

      function formatOptions(preferred) {
        const options = [
          { value: preferred, label: 'Formato original', selected: true },
          { value: 'video_high', label: 'Video alta calidad' },
          { value: 'video_low', label: 'Video ligero' },
          { value: 'audio', label: 'Audio MP3' },
          { value: 'audio_low', label: 'Audio ligero' },
          { value: 'transcripcion', label: 'Transcripción JSON' },
          { value: 'transcripcion_txt', label: 'Transcripción TXT' },
          { value: 'transcripcion_srt', label: 'Subtítulos SRT' },
        ];
        const seen = new Set();
        return options.filter((option) => {
          if (!option.value || seen.has(option.value)) {
            return false;
          }
          seen.add(option.value);
          return true;
        });
      }

      function aggregateCounts(values) {
        const map = new Map();
        values.forEach((value) => {
          if (!value) return;
          map.set(value, (map.get(value) || 0) + 1);
        });
        return [...map.entries()]
          .map(([value, count]) => ({ value, count }))
          .sort((a, b) => b.count - a.count);
      }

      function updateCounters() {
        const counter = document.getElementById('results-counter');
        counter.textContent = `${libraryState.filtered.length} resultados`;
        const active = document.getElementById('active-playlist');
        if (libraryState.activePlaylistId) {
          const playlist = libraryState.playlists.find((pl) => pl.id === libraryState.activePlaylistId);
          active.textContent = playlist ? `Lista activa: ${playlist.name}` : 'Lista personalizada';
        } else if (libraryState.activeCategory === 'favorites') {
          active.textContent = 'Mostrando tus favoritos locales.';
        } else if (libraryState.activeCategory === 'all') {
          active.textContent = 'Mostrando toda la biblioteca.';
        } else {
          active.textContent = `Categoría: ${toTitle(libraryState.activeCategory)}`;
        }
      }

      function renderPlaylistManager() {
        const container = document.getElementById('custom-playlists');
        container.innerHTML = '';
        if (!libraryState.customPlaylists.length) {
          container.innerHTML = '<li class="empty-state">Todavía no has creado playlists personalizadas.</li>';
          return;
        }
        libraryState.customPlaylists.forEach((playlist) => {
          const item = document.createElement('li');
          item.innerHTML = `
            <div>
              <strong>${playlist.name}</strong>
              <small>${playlist.mode === 'static' ? 'Lista estática' : 'Lista dinámica'}</small>
              <p>${playlist.description || 'Sin descripción'}</p>
            </div>
            <button type="button" data-delete-playlist="${playlist.id}">Eliminar</button>
          `;
          container.appendChild(item);
        });
        container.querySelectorAll('[data-delete-playlist]').forEach((button) => {
          button.addEventListener('click', () => deleteCustomPlaylist(button.getAttribute('data-delete-playlist')));
        });
      }

      function handleStaticPlaylistSubmit(event) {
        event.preventDefault();
        const name = document.getElementById('static-playlist-name').value.trim();
        const description = document.getElementById('static-playlist-description').value.trim();
        const entryIds = libraryState.filtered.map((entry) => entry.id);
        if (!entryIds.length) {
          updateStatus('static-playlist-status', 'Necesitas al menos un elemento visible para crear la lista.', true);
          return;
        }
        fetch('/api/playlists', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, description, mode: 'static', entry_ids: entryIds }),
        })
          .then((response) => {
            if (!response.ok) {
              return response.json().then((payload) => {
                throw new Error(payload.detail || 'No se pudo crear la lista estática.');
              });
            }
            return response.json();
          })
          .then(() => {
            updateStatus('static-playlist-status', 'Lista guardada correctamente.');
            event.target.reset();
            return fetchCustomPlaylists();
          })
          .then(() => {
            buildPlaylists();
            renderPlaylistManager();
          })
          .catch((error) => updateStatus('static-playlist-status', error.message, true));
      }

      function handleDynamicPlaylistSubmit(event) {
        event.preventDefault();
        const name = document.getElementById('dynamic-playlist-name').value.trim();
        const description = document.getElementById('dynamic-playlist-description').value.trim();
        const type = document.getElementById('dynamic-rule-type').value;
        const termField = document.getElementById('dynamic-rule-term');
        const minutesField = document.getElementById('dynamic-rule-minutes');
        let rules = { type };
        if (type === 'duration_min' || type === 'duration_max') {
          const minutes = Number.parseInt(minutesField.value, 10);
          if (!minutes) {
            updateStatus('dynamic-playlist-status', 'Indica la duración en minutos.', true);
            return;
          }
          rules.minutes = minutes;
          termField.value = '';
        } else {
          const term = termField.value.trim();
          if (!term) {
            updateStatus('dynamic-playlist-status', 'Indica un término para la regla.', true);
            return;
          }
          rules.term = term;
        }
        fetch('/api/playlists', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, description, mode: 'dynamic', rules }),
        })
          .then((response) => {
            if (!response.ok) {
              return response.json().then((payload) => {
                throw new Error(payload.detail || 'No se pudo crear la lista dinámica.');
              });
            }
            return response.json();
          })
          .then(() => {
            updateStatus('dynamic-playlist-status', 'Lista dinámica creada.');
            event.target.reset();
            return fetchCustomPlaylists();
          })
          .then(() => {
            buildPlaylists();
            renderPlaylistManager();
          })
          .catch((error) => updateStatus('dynamic-playlist-status', error.message, true));
      }

      function deleteCustomPlaylist(id) {
        fetch(`/api/playlists/${id}`, { method: 'DELETE' })
          .then((response) => {
            if (!response.ok) {
              return response.json().then((payload) => {
                throw new Error(payload.detail || 'No se pudo eliminar la lista.');
              });
            }
            return response.json();
          })
          .then(() => fetchCustomPlaylists())
          .then(() => {
            buildPlaylists();
            renderPlaylistManager();
          })
          .catch((error) => updateStatus('static-playlist-status', error.message, true));
      }

      function renderCategoryManager() {
        const container = document.getElementById('category-manager-list');
        container.innerHTML = '';
        if (!libraryState.categoryStats.length) {
          container.innerHTML = '<p class="hint">Añade algún vídeo para empezar a personalizar categorías.</p>';
          return;
        }
        const preferenceMap = new Map(libraryState.categorySettings.map((pref) => [pref.slug, pref]));
        const stats = libraryState.categoryStats.slice().sort((a, b) => a.slug.localeCompare(b.slug));
        stats.forEach(({ slug, count }) => {
          const pref = preferenceMap.get(slug) || {};
          const row = document.createElement('div');
          row.className = 'category-row';
          row.dataset.slug = slug;
          row.setAttribute('data-category-row', 'true');
          row.innerHTML = `
            <div>
              <strong>${toTitle(slug)}</strong>
              <small>${count} elementos</small>
            </div>
            <input type="text" value="${pref.label || ''}" placeholder="Etiqueta personalizada" />
            <label>
              <input type="checkbox" ${pref.hidden ? 'checked' : ''} />
              Ocultar
            </label>
          `;
          container.appendChild(row);
        });
      }

      function handleCategorySettingsSubmit(event) {
        event.preventDefault();
        const rows = document.querySelectorAll('[data-category-row]');
        const settings = [...rows].map((row) => {
          const slug = row.dataset.slug;
          const labelInput = row.querySelector('input[type="text"]');
          const hiddenInput = row.querySelector('input[type="checkbox"]');
          return {
            slug,
            label: labelInput.value.trim() || null,
            hidden: hiddenInput.checked,
          };
        });
        fetch('/api/category-settings', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ settings }),
        })
          .then((response) => {
            if (!response.ok) {
              return response.json().then((payload) => {
                throw new Error(payload.detail || 'No se pudieron guardar las categorías.');
              });
            }
            return response.json();
          })
          .then((payload) => {
            libraryState.categorySettings = Array.isArray(payload.settings) ? payload.settings : [];
            buildCategories();
            renderCategoryManager();
            updateStatus('category-manager-status', 'Preferencias guardadas.');
          })
          .catch((error) => updateStatus('category-manager-status', error.message, true));
      }

      function updateStatus(elementId, message, isError = false) {
        const element = document.getElementById(elementId);
        if (!element) {
          return;
        }
        element.textContent = message;
        element.style.color = isError ? '#f87171' : '#bbf7d0';
        if (message) {
          setTimeout(() => {
            element.textContent = '';
          }, 4000);
        }
      }
    </script>

  </body>
</html>
